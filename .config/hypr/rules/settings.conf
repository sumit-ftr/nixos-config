general {
  border_size = 1 # size of the border around windows
  no_border_on_floating = false # disable borders for floating windows
  gaps_in = 5 # gaps between windows (top, right, bottom, left -> 5,10,15,20)
  gaps_out = 20 # gaps between windows and monitor edges (top, right, bottom, left -> 5,10,15,20)
  gaps_workspaces = 0 # gaps between workspaces. Stacks with gaps_out.
  col.inactive_border = 0xff444444 # border color for inactive windows
  col.active_border = 0xffffffff # border color for the active window
  col.nogroup_border = 0xffffaaff # inactive border color for window that cannot be added to a group (see denywindowfromgroup dispatcher)
  col.nogroup_border_active = 0xffff00ff # active border color for window that cannot be added to a group
  layout = dwindle # [dwindle/master]
  no_focus_fallback =  false # if true, will not fall back to the next available window when moving focus in a direction where no window was found
  resize_on_border = false # enables resizing windows by clicking and dragging on borders and gaps
  extend_border_grab_area = 15 # extends the area around the border where you can click and drag on only used when general:resize_on_border is on.
  hover_icon_on_border = true # show a cursor icon when hovering over borders, only used when general:resize_on_border is on.
  allow_tearing = false # master switch for allowing tearing to occur. See the Tearing page.
  resize_corner = 0 # force floating windows to use a specific corner when being resized (1-4 going clockwise from top left, 0 to disable)

  snap {
    enabled = false # enable snapping for floating windows	bool	
    window_gap = 10 # minimum gap in pixels between windows before snapping	int	
    monitor_gap = 10 # minimum gap in pixels between window and monitor edges before snapping	int	
    border_overlap = false # if true, windows snap such that only one border’s worth of space is between them	bool	
  }
}

decoration {
  rounding = 0 # rounded corner's radius (in layout px)
  rounding_power = 2.0 # adjusts the curve used for rounding corners, larger is smoother, 2.0 is a circle, 4.0 is a squircle. [2.0 - 10.0]
  active_opacity = 1.0 # opacity of active windows. [0.0 - 1.0]
  inactive_opacity = 1.0 # opacity of inactive windows. [0.0 - 1.0]
  fullscreen_opacity = 1.0 # opacity of fullscreen windows. [0.0 - 1.0]
  dim_inactive = false # enables dimming of inactive windows
  dim_strength = 0.5 # how much inactive windows should be dimmed [0.0 - 1.0]
  dim_special = 0.2 # how much to dim the rest of the screen by when a special workspace is open. [0.0 - 1.0]
  dim_around = 0.4 # how much the dimaround window rule should dim by. [0.0 - 1.0]
  screen_shader = [[Empty]] # a path to a custom shader to be applied at the end of rendering. See examples/screenShader.frag for an example.
  border_part_of_window = true # whether the window border should be a part of the window

  blur {
    enabled = true # enable kawase window background blur
    size = 8 # blur size (distance)
    passes = 1 # the amount of passes to perform
    ignore_opacity = true # make the blur layer ignore the opacity of the window
    new_optimizations = true # whether to enable further optimizations to the blur. Recommended to leave on, as it will massively improve performance.
    xray = false # if enabled, floating windows will ignore tiled windows in their blur. Only available if new_optimizations is true. Will reduce overhead on floating blur significantly.
    noise = 0.0117 # how much noise to apply. [0.0 - 1.0]
    contrast = 0.8916 # contrast modulation for blur. [0.0 - 2.0]
    brightness = 0.8172 # brightness modulation for blur. [0.0 - 2.0]
    vibrancy = 0.1696 # Increase saturation of blurred colors. [0.0 - 1.0]
    vibrancy_darkness = 0.0 # How strong the effect of vibrancy is on dark areas. [0.0 - 1.0]
    special = false # whether to blur behind the special workspace (note: expensive)
    popups = false # whether to blur popups (e.g. right-click menus)
    popups_ignorealpha = 0.2 # works like ignorealpha in layer rules. If pixel opacity is below set value, will not blur. [0.0 - 1.0]
    input_methods = false # whether to blur input methods (e.g. fcitx5)
    input_methods_ignorealpha = 0.2 # works like ignorealpha in layer rules. If pixel opacity is below set value, will not blur. [0.0 - 1.0]
  }

  shadow {
    enabled = true # enable drop shadows on windows
    range = 4 # Shadow range (“size”) in layout px
    render_power = 3 # in what power to render the falloff (more power, the faster the falloff) [1 - 4]
    sharp = false # if enabled, will make the shadows sharp, akin to an infinite render power
    ignore_window = true # if true, the shadow will not be rendered behind the window itself, only around it
    color = 0xee1a1a1a # shadow’s color. Alpha dictates shadow’s opacity
    color_inactive = unset # inactive shadow color. (if not set, will fall back to color)
    offset = [0, 0] # shadow’s rendering offset
    scale = 1.0 # shadow’s scale. [0.0 - 1.0]
  }
}
